<!doctype html><html><head><meta name=generator content="Hugo 0.156.0"></head><body><article class="first-entry home-info"><header class=entry-header><h1>Hi, I&rsquo;m Danil</h1></header><div class=entry-content>AppSec engineer | Bug hunter | Security researcher</div><footer class=entry-footer><div class=social-icons></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSRF Pathname Confusion</h2></header><div class=entry-content><p>SSRF via pathname confusion Affected pattern Any Node.js application that constructs internal request URLs using naive string concatenation of the form:
const targetUrl = `http://${host}:${port}${userControlledPathname}`; and then passes this URL to http.request, http.get, axios, fetch, http-proxy, or similar libraries without strict normalization and validation.
This PoC demonstrates a Server-Side Request Forgery (SSRF) vulnerability caused by differences in how Node.js parses URLs when the path contains special characters like *@.
Root cause HTTP/2.0 connection preface starts with a special pseudo-request to check if HTTP/2 is available to use:
...</p></div><footer class=entry-footer><span title='2026-02-21 12:04:29 +0700 +0700'>February 21, 2026</span>&nbsp;Â·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to SSRF Pathname Confusion" href=https://evtdanya.github.io/posts/ssrf-pathname-confusion/></a></article><script data-goatcounter=https://evtdanya.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>